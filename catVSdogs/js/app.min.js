/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\r\n\r\nwindow.addEventListener(\"load\", windowLoad);\r\nfunction windowLoad() {\r\n\r\n    const game = document.querySelector(\"#game\");\r\n\r\n    class Heart {\r\n        img;\r\n        x;\r\n        src = \"img/icons/heart.svg\";\r\n        block;\r\n        blockSize = 32;\r\n        maxPosXSprite = 4;\r\n\r\n        generateHearts(x, y) {\r\n            this.block = document.createElement('div');\r\n            this.block.classList.add(\"active\");\r\n            this.block.id = \"heart\";\r\n            this.block.style.cssText = `\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                position: absolute;\r\n                overflow: hidden;\r\n                top: ${y * 32}px;\r\n                left: ${x * 32}px;\r\n            `;\r\n            this.img = document.createElement('img');\r\n            this.img.src = this.src;\r\n            this.img.style.cssText = `\r\n                width: ${this.blockSize * this.maxPosXSprite}px;\r\n                height: ${this.block}px;\r\n                position: absolute;\r\n                top: 0px;\r\n                left: 0px;\r\n            `;\r\n\r\n            game.appendChild(this.block);\r\n            this.block.appendChild(this.img);\r\n        }\r\n    }\r\n    const hearts = new Heart();\r\n    function killHeart() {\r\n        const allHearts = document.querySelectorAll(\"#heart.active\");\r\n        if (allHearts.length) {\r\n            const currentHeart = allHearts[allHearts.length - 1];\r\n            currentHeart.classList.remove(\"active\");\r\n            const img = currentHeart.querySelector(\"img\");\r\n            let posXSprite = 0;\r\n\r\n            const animationHeart = setInterval(() => {\r\n                if (posXSprite <= 3) {\r\n                    img.style.left = -posXSprite * 32 + \"px\";\r\n                    posXSprite++;\r\n                } else {\r\n                    clearInterval(animationHeart);\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n\r\n    //Главный персонаж\r\n    const hero = document.querySelector(\"#hero\");\r\n    //Картинка главного персонажа\r\n    const heroImg = document.querySelector(\"#mainHeroes\");\r\n\r\n    let lives = 5;\r\n\r\n    //Позиции для главного персонажа\r\n    let leftPosMainHero = 0;\r\n    let translateMainHero = 32;\r\n    let topMainHero = 0;\r\n\r\n    const heroBlockSize = 96;\r\n    let MaxBlocksXHero = 7;\r\n\r\n    let state = \"stand\";\r\n\r\n    //В какую сторону повернут кот\r\n    let direction = \"right\";\r\n    //переменная для анимации\r\n    let animation;\r\n    let animationSome;\r\n    let animateWasChanged = true;\r\n\r\n    let heroX = Math.ceil(Number.parseInt(getComputedStyle(hero).left) / 32);\r\n    let heroY = Math.ceil(Number.parseInt(getComputedStyle(hero).bottom) / 32);\r\n\r\n    let isFalling = false;\r\n\r\n    const heightJump = 150;\r\n\r\n    //для блокировок ходьбы персонажа в какую-либо сторону при получении урона\r\n    let isRightSideBlocked = false;\r\n    let isLeftSideBlocked = false;\r\n\r\n\r\n    //для карты переменные\r\n    let tileArray = [];\r\n\r\n    //Функция для иземенеия состояния персонажа\r\n    function changeAnimate(stateStr) {\r\n        clearInterval(animation);\r\n        clearInterval(animationSome);\r\n        animation = null;\r\n        animationSome = null;\r\n        animateWasChanged = true;\r\n        state = stateStr;\r\n    }\r\n\r\n    //Обработчик нажатия на клавишу\r\n    document.addEventListener(\"keydown\", (e) => {\r\n        const keyPressed = e.code;\r\n\r\n        if (keyPressed === \"KeyD\" || keyPressed === \"ArrowRight\") {\r\n            if (!isRightSideBlocked) {\r\n                if (state != \"rightWalk\" && state != \"fall\" && state != \"hurt\") {\r\n                    changeAnimate(\"rightWalk\");\r\n                    rightHandler();\r\n                }\r\n            }\r\n        }\r\n        if (keyPressed === \"KeyA\" || keyPressed === \"ArrowLeft\") {\r\n            if (!isLeftSideBlocked) {\r\n                if (state != \"leftWalk\" && state != \"fall\" && state != \"hurt\") {\r\n                    changeAnimate(\"leftWalk\");\r\n                    leftHandler();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (keyPressed === \"KeyF\") {\r\n            if (state != \"jump\" && state != \"fall\" && state != \"hit\" && state != \"hurt\") {\r\n                changeAnimate(\"hit\");\r\n                hitHandler();\r\n            }\r\n\r\n        }\r\n        if (keyPressed === \"KeyW\" || keyPressed === \"Space\" || keyPressed === \"ArrowUp\") {\r\n            if (state != \"jump\" && state != \"fall\" && state != \"hurt\") {\r\n                changeAnimate(\"jump\");\r\n                jumpHandler();\r\n            }\r\n        }\r\n    });\r\n    //Обработчик опускания клавиши\r\n    document.addEventListener(\"keyup\", (e) => {\r\n        if (state != \"fall\" && state != \"jump\" && state != \"hit\")\r\n            changeAnimate(\"stand\");\r\n    });\r\n\r\n    //ФУнкция передвижения главного героя вправо\r\n    function rightHandler() {\r\n\r\n        heroImg.style.top = \"0px\";\r\n        heroImg.style.transform = \"scale(1, 1)\";\r\n        direction = \"right\";\r\n\r\n        animation = setInterval(() => {\r\n            leftPosMainHero <= -heroBlockSize * (MaxBlocksXHero - 1) ? leftPosMainHero = 0 : leftPosMainHero -= heroBlockSize;\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, 60);\r\n\r\n        animationSome = setInterval(() => {\r\n            translateMainHero >= 2000 ? null : translateMainHero += 3;\r\n            hero.style.left = translateMainHero + \"px\";\r\n\r\n            checkFalling();\r\n            if (isFalling)\r\n                changeAnimate(\"fall\");\r\n\r\n            if (isRightSideBlocked) {\r\n                changeAnimate(\"stand\");\r\n            }\r\n        }, 17);\r\n\r\n    }\r\n    //передвижение влево\r\n    function leftHandler() {\r\n\r\n        heroImg.style.top = \"0px\";\r\n        heroImg.style.transform = \"scale(-1, 1)\";\r\n        direction = \"left\";\r\n\r\n        animation = setInterval(() => {\r\n            leftPosMainHero >= 0 ? leftPosMainHero = -heroBlockSize * (MaxBlocksXHero - 1) : leftPosMainHero += heroBlockSize;\r\n\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, 60);\r\n\r\n        animationSome = setInterval(() => {\r\n            hero.style.left = translateMainHero + \"px\";\r\n            translateMainHero <= 32 ? null : translateMainHero -= 3;\r\n\r\n            checkFalling();\r\n            if (isFalling)\r\n                changeAnimate(\"fall\");\r\n\r\n            if (isLeftSideBlocked) {\r\n                changeAnimate(\"stand\");\r\n            }\r\n        }, 17);\r\n    }\r\n    //анимация стоянки\r\n    function standHanlder() {\r\n        animation = setInterval(() => {\r\n            if (direction === \"right\") {\r\n                leftPosMainHero <= -heroBlockSize ? leftPosMainHero = 0 : leftPosMainHero -= heroBlockSize;\r\n                heroImg.style.transform = \"scale(1, 1)\";\r\n            } else {\r\n                leftPosMainHero >= -((MaxBlocksXHero - 1) * heroBlockSize - heroBlockSize) ? leftPosMainHero = -(MaxBlocksXHero - 1) * heroBlockSize : leftPosMainHero += heroBlockSize;\r\n                heroImg.style.transform = \"scale(-1, 1)\";\r\n            }\r\n\r\n            heroImg.style.top = \"-\" + heroBlockSize + \"px\";\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, 100);\r\n    }\r\n    //Удар\r\n    function hitHandler() {\r\n        heroImg.style.top = -heroBlockSize * 3 + \"px\";\r\n        if (direction === \"right\") {\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n            heroImg.style.left = \"0px\";\r\n            leftPosMainHero = 0;\r\n\r\n            animation = setInterval(() => {\r\n                if (leftPosMainHero <= -heroBlockSize * 5) {\r\n                    changeAnimate(\"stand\");\r\n                } else {\r\n                    leftPosMainHero -= heroBlockSize;\r\n                    heroImg.style.left = leftPosMainHero + \"px\";\r\n                }\r\n            }, 150);\r\n\r\n        } else {\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n            heroImg.style.left = -(MaxBlocksXHero * heroBlockSize - 6 * heroBlockSize) + \"px\";\r\n            leftPosMainHero = -(MaxBlocksXHero * heroBlockSize - 6 * heroBlockSize);\r\n\r\n            animation = setInterval(() => {\r\n                if (leftPosMainHero <= -(MaxBlocksXHero - 1) * heroBlockSize) {\r\n                    changeAnimate(\"stand\");\r\n                } else {\r\n                    leftPosMainHero -= heroBlockSize;\r\n                    heroImg.style.left = leftPosMainHero + \"px\";\r\n                }\r\n            }, 150);\r\n        }\r\n\r\n\r\n\r\n    }\r\n    //Прыжок\r\n    function jumpHandler() {\r\n        topMainHero = heroY * 32;\r\n        const startPosY = topMainHero;\r\n        //картинка прышка\r\n        heroImg.style.top = -heroBlockSize * 2 + \"px\";\r\n\r\n        //установка изначального положения спрайта\r\n        if (direction === \"right\") {\r\n            heroImg.style.left = \"0px\";\r\n            leftPosMainHero = 0;\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n        }\r\n        else {\r\n            heroImg.style.left = -heroBlockSize * MaxBlocksXHero + \"px\";\r\n            leftPosMainHero = -heroBlockSize * MaxBlocksXHero;\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n        }  \r\n\r\n        animationSome = setInterval(() => {\r\n            if (direction === \"right\") {\r\n                leftPosMainHero <= -heroBlockSize * 4 ? leftPosMainHero = 0 : leftPosMainHero -= heroBlockSize;\r\n            } else {\r\n                leftPosMainHero >= -(MaxBlocksXHero - heroBlockSize * 4) ? leftPosMainHero = -heroBlockSize * MaxBlocksXHero : leftPosMainHero += heroBlockSize;\r\n            }\r\n\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, heightJump / 10 * 17 / 4);\r\n\r\n        //передвижение персонажа\r\n        animation = setInterval(() => {\r\n            topMainHero += 10;\r\n            if (topMainHero - startPosY > heightJump) {\r\n                checkFalling();\r\n                if (isFalling) {\r\n                    changeAnimate(\"fall\");\r\n                }\r\n                else changeAnimate(\"stand\");\r\n            }\r\n\r\n            if (direction === \"right\") {\r\n                translateMainHero += 10;\r\n                hero.style.left = translateMainHero + \"px\";\r\n            } else {\r\n                translateMainHero -= 10;\r\n                hero.style.left = translateMainHero + \"px\";\r\n            }\r\n            hero.style.bottom = topMainHero + \"px\";\r\n        }, 17);\r\n    }\r\n    function fallHandler() {\r\n\r\n        heroImg.style.top = -(heroBlockSize * 2) + \"px\";\r\n        if (direction === \"right\") {\r\n            leftPosMainHero = -(heroBlockSize * 2);\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n        } else {\r\n            leftPosMainHero = -(heroBlockSize * 3);\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n        }\r\n\r\n\r\n        animation = setInterval(() => {\r\n            topMainHero -= 3;\r\n            hero.style.bottom = topMainHero + \"px\";\r\n            checkFalling();\r\n            if (!isFalling) {\r\n                hero.style.bottom = `${heroY * 32}px`;\r\n                changeAnimate(\"stand\");\r\n            }\r\n        }, 17);\r\n\r\n\r\n        heroImg.style.left = leftPosMainHero + \"px\";\r\n\r\n\r\n    }\r\n    function hurtHanlder() {\r\n        heroImg.style.top = -heroBlockSize * 4 + \"px\";\r\n        if (direction === \"right\") {\r\n            heroImg.style.left = \"0px\";\r\n        } else {\r\n            heroImg.style.left = -(MaxBlocksXHero - 1) * heroBlockSize + \"px\";\r\n        }\r\n\r\n        setTimeout(() => {\r\n            changeAnimate(\"stand\");\r\n        }, 100);\r\n    }\r\n\r\n\r\n    function createTile(x, y = 1) {\r\n        const tile = document.createElement(\"img\");\r\n        tile.src = \"img/tiles/main.svg\";\r\n        tile.style.cssText = `\r\n            position: absolute;\r\n            left: ${x * 32}px;\r\n            bottom: ${y * 32}px;\r\n            width: 32px;\r\n            height: 32px;\r\n        `;\r\n        game.appendChild(tile);\r\n\r\n        tileArray.push([x, y]);\r\n    }\r\n    function addTiles(i) {\r\n        createTile(i);\r\n\r\n        const tileBottom = document.createElement(\"img\");\r\n        tileBottom.src = \"img/tiles/foundation.svg\";\r\n        tileBottom.style.cssText = `\r\n            position: absolute;\r\n            left: ${i * 32}px;\r\n            bottom: 0;\r\n            width: 32px;\r\n            height: 32px;\r\n        `;\r\n        game.appendChild(tileBottom);\r\n    }\r\n    function createTilesPlatform(startX, startY, lenght) {\r\n        for (let i = 0; i < lenght; i++) {\r\n            createTile(startX + i, startY);\r\n        }\r\n    }\r\n\r\n    function updateHeroXY() {\r\n        heroX = Math.ceil(Number.parseInt(getComputedStyle(hero).left) / 32);\r\n        heroY = Math.ceil(Number.parseInt(getComputedStyle(hero).bottom) / 32);\r\n    }\r\n\r\n\r\n    function checkFalling() {\r\n        updateHeroXY();\r\n        isFalling = true;\r\n        for (let i = 0; i < tileArray.length; i++) {\r\n            if (tileArray[i][0] === heroX && tileArray[i][1] + 1 === heroY) {\r\n                isFalling = false;\r\n                break;\r\n            } else if (tileArray[i][0] === heroX + 1 && tileArray[i][1] + 1 === heroY) {\r\n                isFalling = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function lifeCycle() {\r\n        setInterval(() => {\r\n            if (animateWasChanged) {\r\n                animateWasChanged = false;\r\n                if (state === \"fall\") {\r\n                    fallHandler();\r\n                    /*   } else if (state === \"jump\") {\r\n                          jumpHandler(); */\r\n                    /*  } else if (state === \"hitt\") {\r\n                         hitHandler(); */\r\n                } else if (state === \"stand\") {\r\n                    standHanlder();\r\n                } else if (state === \"hurt\") {\r\n                    hurtHanlder();\r\n                }\r\n                \r\n            }\r\n        }, 17);\r\n    }\r\n\r\n    function start() {\r\n\r\n        lifeCycle();\r\n\r\n        for (let i = 0; i < 100; i++) {\r\n            if (i > 10 && i < 12) continue;\r\n            addTiles(i);\r\n        }\r\n\r\n        createTilesPlatform(10, 6, 15);\r\n        createTilesPlatform(34, 2, 5);\r\n\r\n        new Enemy(25, 2);\r\n\r\n        for (let index = 0.5; index < lives + 0.5; index++) {\r\n            hearts.generateHearts(index, 0.5);\r\n        }\r\n\r\n    }\r\n\r\n    //Класс для генерации врага\r\n    class Enemy {\r\n\r\n        STAND = \"stand\";\r\n        ATTACK = \"attack\";\r\n        DEATH = \"death\";\r\n        WALK = \"walk\";\r\n        HURT = \"hurt\";\r\n\r\n        posX;\r\n        posY;\r\n        startX;\r\n        travelInterval = 6;\r\n        direction = .1;\r\n        img;\r\n        block;\r\n        blockSize = 96;\r\n        timer;\r\n        animation;\r\n        animationSome;\r\n        state = \"stand\";\r\n        attack = false;\r\n        animateWasChanged = true;\r\n\r\n        SpriteMaxPosX = 6;\r\n        SpriteMaxPosY = 5;\r\n        SpritePosX = 0;\r\n        SpritePosY = 0;\r\n\r\n        NumPosStand = 2;\r\n        NumPosHurt = 1;\r\n        NumPosWalk = 5;\r\n        NumPosAttack = 3;\r\n        NUmPosDeath = 3;\r\n\r\n        lives = 2;\r\n\r\n        constructor(x, y) {\r\n            this.posX = x;\r\n            this.posY = y;\r\n            this.startX = this.posX;\r\n\r\n            this.createEnimy();\r\n\r\n            //this.changeAnimate(this.WALK);\r\n            this.lifeCycle();\r\n\r\n            this.changeAnimate(this.WALK);\r\n            /* setInterval(() => {\r\n                if (this.state === this.STAND)\r\n                    this.changeAnimate(this.WALK);\r\n                else if (this.state === this.WALK)\r\n                    this.changeAnimate(this.STAND);\r\n            }, 3000); */\r\n        }\r\n\r\n        createEnimy() {\r\n            this.block = document.createElement('div');\r\n            this.block.style.cssText = `\r\n                position: absolute;\r\n                left: ${this.posX * 32}px;\r\n                bottom: ${this.posY * 32}px;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n            `;\r\n            game.appendChild(this.block);\r\n\r\n            this.img = document.createElement(\"img\");\r\n            this.img.src = \"img/characters/enemies/StandDog.svg\";\r\n            this.img.style.cssText = `\r\n                position: absolute;\r\n                left: 0;\r\n                bottom: 0;\r\n                width: ${this.blockSize * this.SpriteMaxPosX}px;\r\n                height: ${this.blockSize * this.SpriteMaxPosY}px;\r\n            `;\r\n            this.block.appendChild(this.img);\r\n        }\r\n\r\n        lifeCycle() {\r\n            this.timer = setInterval(() => {\r\n\r\n                this.checkCollide();\r\n\r\n                if (this.animateWasChanged) {\r\n                    this.animateWasChanged = false;\r\n                    switch (this.state) {\r\n                        case this.DEATH:\r\n                            this.deathAnimate();\r\n                            break;\r\n                        case this.HURT:\r\n                            this.hurtAnimate();\r\n                            break;\r\n                        case this.WALK:\r\n                            this.walkAnimate();\r\n                            break;\r\n                        case this.STAND:\r\n                            this.standAnimate();\r\n                            break;\r\n                        case this.ATTACK:\r\n                            this.attackAnimate();\r\n                            break;\r\n                        case this.DEATH:\r\n                            this.deathAnimate();\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            }, 17);\r\n        }\r\n\r\n        //Проверка столкновения с героем\r\n        checkCollide() {\r\n            if (heroY == this.posY) {\r\n                if (heroX == Math.floor(this.posX)) {\r\n                    isRightSideBlocked = true;\r\n                    isLeftSideBlocked = false;\r\n                    if (state === \"hit\" && this.state != this.HURT) {\r\n                        this.changeAnimate(this.HURT);\r\n                        lives--;\r\n                        if (lives <= 0) this.changeAnimate(this.DEATH);\r\n                    } else if (!this.attack) {\r\n                        this.changeAnimate(this.ATTACK);\r\n                    }\r\n                } else if (heroX == Math.floor(this.posX + 2) || heroX == Math.floor(this.posX + 1)) {\r\n                    isLeftSideBlocked = true;\r\n                    isRightSideBlocked = false;\r\n                    if (state === \"hit\" && this.state != this.HURT) {\r\n                        this.changeAnimate(this.HURT);\r\n                        lives--;\r\n                        if (lives <= 0) this.changeAnimate(this.DEATH);\r\n                    } else if (!this.attack) {\r\n                        this.changeAnimate(this.ATTACK);\r\n                    }\r\n                } else if (this.state === this.ATTACK) {\r\n                    this.changeAnimate(this.WALK);\r\n                    this.attack = false;\r\n\r\n                    isLeftSideBlocked = false;\r\n                    isRightSideBlocked = false;\r\n                }\r\n            } else if (this.state === this.ATTACK) {\r\n                this.changeAnimate(this.WALK);\r\n                this.attack = false;\r\n\r\n                isLeftSideBlocked = false;\r\n                isRightSideBlocked = false;\r\n            }\r\n        }\r\n\r\n        changeAnimate(stateStr) {\r\n            clearInterval(this.animation);\r\n            this.animation = null;\r\n            clearInterval(this.animationSome);\r\n            this.animationSome = null;\r\n\r\n            this.state = stateStr;\r\n            this.animateWasChanged = true;\r\n        }\r\n\r\n        standAnimate() {\r\n            this.img.style.top = \"0px\";\r\n            this.img.style.left = \"0px\";\r\n            this.SpritePosX = 1;\r\n            this.animation = setInterval(() => {\r\n\r\n                if (this.direction === Math.abs(this.direction)) {\r\n                    this.img.style.transform = \"scale(-1, 1)\";\r\n\r\n                    if (-this.SpritePosX * this.blockSize >= (-(this.SpriteMaxPosX - 1 - this.NumPosStand) * this.blockSize)) {\r\n                        this.SpritePosX = this.SpriteMaxPosX;\r\n                    } else {\r\n                        this.SpritePosX--;\r\n                        this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                    }\r\n                } else {\r\n                    this.img.style.transform = \"scale(1, 1)\";\r\n\r\n                    this.SpritePosX === this.NumPosStand ? this.SpritePosX = 0 : this.SpritePosX++;\r\n                    this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                }\r\n            }, 100);\r\n        }\r\n\r\n        walkAnimate() {\r\n            this.img.style.top = -this.blockSize * 4 + \"px\";\r\n            this.img.style.left = \"0px\";\r\n            this.SpritePosX = 1;\r\n            this.animationSome = setInterval(() => {\r\n                if (this.posX > this.startX + this.travelInterval) {\r\n                    this.direction *= -1;\r\n                    this.img.style.transform = \"scale(1, 1)\";\r\n                }\r\n                else if (this.posX <= this.startX) {\r\n                    this.direction = Math.abs(this.direction);\r\n                    this.img.style.transform = \"scale(-1, 1)\";\r\n                }\r\n\r\n                this.posX += this.direction;\r\n                this.block.style.left = this.posX * 32 + \"px\";\r\n            }, 17);\r\n            this.animation = setInterval(() => {\r\n                this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                this.SpritePosX === this.NumPosWalk ? this.SpritePosX = 0 : this.SpritePosX++;\r\n            }, 100);\r\n        }\r\n\r\n        attackAnimate() {\r\n            this.attack = true;\r\n            this.img.style.top = this.blockSize * -2 + \"px\";\r\n            this.img.style.left = \"0px\";\r\n\r\n            this.SpritePosX = 0;\r\n\r\n            this.animation = setInterval(() => {\r\n                if (this.direction === Math.abs(this.direction)) {\r\n                    this.img.style.transform = \"scale(-1, 1)\";\r\n\r\n                    if (-this.SpritePosX * this.blockSize >= (-(this.SpriteMaxPosX - 1 - this.NumPosAttack) * this.blockSize)) {\r\n                        this.SpritePosX = this.SpriteMaxPosX;\r\n\r\n                        changeAnimate(\"hurt\");\r\n                        lives--;\r\n                        killHeart();\r\n                    } else {\r\n                        this.SpritePosX--;\r\n                        this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                    }\r\n                } else {\r\n                    this.img.style.transform = \"scale(1, 1)\";\r\n                    if (this.SpritePosX >= this.NumPosAttack) {\r\n                        this.SpritePosX = 0;\r\n\r\n                        changeAnimate(\"hurt\");\r\n                        lives--;\r\n                        killHeart();\r\n                    } else {\r\n                        this.SpritePosX++;\r\n                        this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                    }\r\n                }\r\n\r\n            }, 150);\r\n        }\r\n\r\n        deathAnimate() {\r\n            this.img.style.top = -1 * this.blockSize + \"px\";\r\n\r\n            //если повернут влево(по умолчанию)\r\n            if (this.direction === Math.abs(this.direction)) {\r\n                this.img.style.transform = \"scale(-1, 1)\";\r\n                this.img.style.left = -(this.SpriteMaxPosX - this.NUmPosDeath * this.blockSize) + \"px\";\r\n                this.posXSprite = this.SpriteMaxPosX - this.NUmPosDeath;\r\n\r\n                animation = setInterval(() => {\r\n                    if (this.posXSprite >= this.SpriteMaxPosX) {\r\n                        //смерть\r\n                        //this.block.style.display = \"none\";\r\n                        //clearInterval(animation);\r\n                        //this.changeAnimate(this.STAND);\r\n                    } else {\r\n                        this.img.style.left = -this.SpriteMaxPosX * this.blockSize + \"px\";\r\n                        this.posXSprite++;\r\n                    }\r\n                }, 300);\r\n\r\n                //если повернут вправо\r\n            } else {\r\n                this.img.style.transform = \"scale(1, 1)\";\r\n                this.img.style.left = \"0px\";\r\n                this.posXSprite = 0;\r\n\r\n                animation = setInterval(() => {\r\n                    if (this.posXSprite >= this.NUmPosDeath) {\r\n                        //смерть\r\n                        //this.block.style.display = \"none\";\r\n                        //(animation);\r\n                        //this.changeAnimate(this.STAND);\r\n                    } else {\r\n                        this.img.style.left = this.posXSprite * this.blockSize + \"px\";\r\n                        this.posXSprite++;\r\n                    }\r\n                }, 300);\r\n            }\r\n        }\r\n\r\n        hurtAnimate() {\r\n            this.img.style.top = -3 * this.blockSize + \"px\";\r\n            if (this.direction === Math.abs(this.direction)) {\r\n                this.img.style.transform = \"scale(-1, 1)\";\r\n                this.img.style.left = -(this.maxPosXSprite - this.NumPosHurt) * this.blockSize + \"px\";\r\n            } else {\r\n                this.img.style.transform = \"scale(1, 1)\";\r\n                this.img.style.left = -this.NumPosHurt * this.blockSize + \"px\";\r\n            }\r\n\r\n            setTimeout(() => {\r\n                this.changeAnimate(this.ATTACK);\r\n            }, 300);\r\n\r\n        }\r\n    }\r\n\r\n    start();\r\n}\n\n//# sourceURL=webpack://newgulp/./src/js/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/app.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;