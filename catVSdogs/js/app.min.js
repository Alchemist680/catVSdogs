/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\r\n\r\nwindow.addEventListener(\"load\", windowLoad);\r\nfunction windowLoad() {\r\n\r\n\r\n    let timer;\r\n    let statusGame = 'default';\r\n\r\n    document.addEventListener('click', documentActions)\r\n    function documentActions(e) {\r\n        const targetElement = e.target;\r\n\r\n        //?Открывание мобального окна (по классу open)\r\n        //атрибуты: data-button-for-open-custom-popup=\"popup\" - кнопка открывания; data-custom-popup=\"popup\" - попап; data-close-for-custom-popup - кнопка закрывания (обязательно внутри попапа);  data-custom-popup-content - контентная оболочка (внутри попапа внутри body попапа).\r\n        if (targetElement.closest(\"[data-close-for-custom-popup]\")) {\r\n            const popup = targetElement.closest(\"[data-custom-popup]\");\r\n            if (popup) {\r\n                popup.classList.remove('open');\r\n                //Устранение дергания при убирании скрола\r\n                document.body.style.overflow = \"auto\";\r\n                document.body.style.paddingRight = 0;\r\n                const header = document.querySelector(\"header\");\r\n                if (header) {\r\n                    header.style.paddingRight = 0;\r\n                }\r\n            }\r\n        }\r\n        if (targetElement.closest(\"[data-button-for-open-custom-popup]\")) {\r\n            if (timer && statusGame === 'pause') {\r\n                timer.startTimer();\r\n                statusGame = 'default';\r\n            }\r\n            const popupName = targetElement.closest(\"[data-button-for-open-custom-popup]\").dataset.buttonForOpenCustomPopup;\r\n            const popup = document.querySelector(`[data-custom-popup=\"${popupName}\"]`);\r\n            if (popup) {\r\n                popup.classList.add('open');\r\n                //Устранение дергания при убирании скрола\r\n                const lockPaddingValue = window.innerWidth - document.body.offsetWidth + 'px';\r\n                document.body.style.paddingRight = lockPaddingValue;\r\n                document.body.style.overflow = \"hidden\";\r\n                const header = document.querySelector(\"header\");\r\n                if (header) {\r\n                    header.style.paddingRight = lockPaddingValue;\r\n                }\r\n\r\n                e.preventDefault();\r\n            }\r\n        } else if (!targetElement.closest(\"[data-custom-popup].open [data-custom-popup-content]\")) {\r\n            if (timer && statusGame === 'pause') {\r\n                timer.startTimer();\r\n                statusGame = 'default';\r\n            }\r\n            const popup = document.querySelector(\"[data-custom-popup].open\");\r\n            if (popup) {\r\n                popup.classList.remove('open');\r\n\r\n                //Устранение дергания при убирании скрола\r\n                document.body.style.overflow = \"auto\";\r\n                document.body.style.paddingRight = 0;\r\n                const header = document.querySelector(\"header\");\r\n                if (header) {\r\n                    header.style.paddingRight = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        //отрытие настроек\r\n        if (targetElement.closest(\"#settings\")) {\r\n            const popupName = statusGame;\r\n            const popup = document.querySelector(`[data-custom-popup=\"${popupName}\"]`);\r\n            if (popup) {\r\n\r\n                if (timer && statusGame === 'default') {\r\n                    timer.stopTimer();\r\n                    statusGame = 'pause';\r\n                    popup.querySelector(\".timeGame\").innerText = timer.getTime();\r\n                }\r\n\r\n                popup.classList.add('open');\r\n                //Устранение дергания при убирании скрола\r\n                const lockPaddingValue = window.innerWidth - document.body.offsetWidth + 'px';\r\n                document.body.style.paddingRight = lockPaddingValue;\r\n                document.body.style.overflow = \"hidden\";\r\n                const header = document.querySelector(\"header\");\r\n                if (header) {\r\n                    header.style.paddingRight = lockPaddingValue;\r\n                }\r\n\r\n                e.preventDefault();\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    const game = document.querySelector(\"#game\");\r\n    let victoryLodge;\r\n    let isGameNotOver = true;\r\n    let isUserStartGame = false;\r\n\r\n    //жизни в левом верхнем углу\r\n    class Heart {\r\n        img;\r\n        x;\r\n        src = \"img/icons/heart.svg\";\r\n        block;\r\n        blockSize = 32;\r\n        maxPosXSprite = 4;\r\n\r\n        generateHearts(x, y) {\r\n            this.block = document.createElement('div');\r\n            this.block.classList.add(\"active\");\r\n            this.block.id = \"heart\";\r\n            this.block.style.cssText = `\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                position: absolute;\r\n                overflow: hidden;\r\n                top: ${y * 32}px;\r\n                left: ${x * 32}px;\r\n            `;\r\n            this.img = document.createElement('img');\r\n            this.img.src = this.src;\r\n            this.img.style.cssText = `\r\n                width: ${this.blockSize * this.maxPosXSprite}px;\r\n                height: ${this.block}px;\r\n                position: absolute;\r\n                top: 0px;\r\n                left: 0px;\r\n            `;\r\n\r\n            game.appendChild(this.block);\r\n            this.block.appendChild(this.img);\r\n        }\r\n    }\r\n    const hearts = new Heart();\r\n    function killHeart() {\r\n        const allHearts = document.querySelectorAll(\"#heart.active\");\r\n        lives--;\r\n        if (allHearts.length) {\r\n            const currentHeart = allHearts[allHearts.length - 1];\r\n            currentHeart.classList.remove(\"active\");\r\n            const img = currentHeart.querySelector(\"img\");\r\n            let posXSprite = 0;\r\n\r\n            const animationHeart = setInterval(() => {\r\n                if (posXSprite <= 3) {\r\n                    img.style.left = -posXSprite * 32 + \"px\";\r\n                    posXSprite++;\r\n                } else {\r\n                    clearInterval(animationHeart);\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n    function addHeart() {\r\n        lives++;\r\n        const allHearts = document.querySelectorAll(\"#heart\");\r\n        console.log(allHearts);\r\n        if (allHearts.length) {\r\n            const currentHeart = allHearts[allHearts.length - 1];\r\n            console.log(currentHeart);\r\n            currentHeart.classList.add(\"active\");\r\n            const img = currentHeart.querySelector(\"img\");\r\n            let posXSprite = 3;\r\n\r\n            const animationHeart = setInterval(() => {\r\n                if (posXSprite >= 0) {\r\n                    img.style.left = -posXSprite * 32 + \"px\";\r\n                    posXSprite--;\r\n                } else {\r\n                    clearInterval(animationHeart);\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n\r\n    //Главный персонаж\r\n    const hero = document.querySelector(\"#hero\");\r\n    //Картинка главного персонажа\r\n    const heroImg = document.querySelector(\"#mainHeroes\");\r\n\r\n    let arrayEnemies = [];\r\n\r\n    let lives = 8;\r\n    let maxLives = lives;\r\n\r\n    //Скорость передвижения (3 пикселя каждые 17 мс => 180пикс в секунду)\r\n    let speed = 8;\r\n\r\n    //Позиции для главного персонажа\r\n    let leftPosMainHero = 0;\r\n    //let translateMainHero = 64;\r\n    let topMainHero = 0;\r\n\r\n    const heroBlockSize = 96;\r\n    let MaxBlocksXHero = 7;\r\n\r\n    let state = \"stand\";\r\n\r\n    //В какую сторону повернут кот\r\n    let direction = \"right\";\r\n    //переменная для анимации\r\n    let animation;\r\n    let animationSome;\r\n    let animateWasChanged = true;\r\n    let lifeCycleTimer;\r\n\r\n    let heroX = Math.ceil(Number.parseInt(getComputedStyle(hero).left) / 32);\r\n    let heroY = Math.ceil(Number.parseInt(getComputedStyle(hero).bottom) / 32);\r\n\r\n    let isFalling = false;\r\n\r\n    let heightJump = 150;\r\n\r\n    //для блокировок ходьбы персонажа в какую-либо сторону при получении урона\r\n    let isRightSideBlocked = false;\r\n    let isLeftSideBlocked = false;\r\n\r\n\r\n    //для карты переменные\r\n    let tileArray = [];\r\n    let AllEnemy = [];\r\n    let allObjects = document.createElement(\"div\");\r\n    allObjects.style.cssText = `\r\n        position: absolute;\r\n        left: 0px;\r\n        top: 0px;\r\n        width: 100%;\r\n        height: 100%;\r\n    `;\r\n    game.appendChild(allObjects);\r\n\r\n    //Функция для иземенеия состояния персонажа\r\n    function changeAnimate(stateStr) {\r\n        clearInterval(animation);\r\n        clearInterval(animationSome);\r\n        animation = null;\r\n        animationSome = null;\r\n        animateWasChanged = true;\r\n        state = stateStr;\r\n    }\r\n\r\n    //Обработчик нажатия на клавишу\r\n    document.addEventListener(\"keydown\", Managementtracking);\r\n    function Managementtracking(e) {\r\n        const keyPressed = e.code;\r\n        if (isGameNotOver) {\r\n\r\n            //запуск таймера\r\n            if (isUserStartGame === false) {\r\n                isUserStartGame = true;\r\n                timer = new Timer();\r\n            }\r\n\r\n            if (keyPressed === \"KeyD\" || keyPressed === \"ArrowRight\") {\r\n                if (!isRightSideBlocked) {\r\n                    if (state != \"rightWalk\" && state != \"fall\" && state != \"hurt\" && state != \"death\") {\r\n                        changeAnimate(\"rightWalk\");\r\n                        rightHandler();\r\n                    }\r\n                }\r\n            }\r\n            if (keyPressed === \"KeyA\" || keyPressed === \"ArrowLeft\") {\r\n                if (!isLeftSideBlocked) {\r\n                    if (state != \"leftWalk\" && state != \"fall\" && state != \"hurt\" && state != \"death\") {\r\n                        changeAnimate(\"leftWalk\");\r\n                        leftHandler();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (keyPressed === \"KeyF\") {\r\n                if (state != \"jump\" && state != \"fall\" && state != \"hit\" && state != \"hurt\" && state != \"death\") {\r\n                    changeAnimate(\"hit\");\r\n                    hitHandler();\r\n                }\r\n\r\n            }\r\n            if (keyPressed === \"KeyW\" || keyPressed === \"Space\" || keyPressed === \"ArrowUp\" && state != \"death\") {\r\n                if (state != \"jump\" && state != \"fall\" && state != \"hurt\") {\r\n                    changeAnimate(\"jump\");\r\n                    jumpHandler();\r\n                }\r\n            }\r\n        }\r\n\r\n        //закрывание открытого попапа\r\n        if (keyPressed === \"Escape\") {\r\n            const popup = document.querySelector(\"[data-custom-popup].open\");\r\n            if (timer && statusGame === 'pause') {\r\n                statusGame = 'default';\r\n                timer.startTimer();\r\n            }\r\n            if (popup) {\r\n                popup.classList.remove('open');\r\n                //Устранение дергания при убирании скрола\r\n                document.body.style.overflow = \"auto\";\r\n                document.body.style.paddingRight = 0;\r\n                const header = document.querySelector(\"header\");\r\n                if (header) {\r\n                    header.style.paddingRight = 0;\r\n                }\r\n            } else {\r\n                const popupName = statusGame;\r\n                const popup = document.querySelector(`[data-custom-popup=\"${popupName}\"]`);\r\n                if (popup) {\r\n\r\n                    if (timer && statusGame === 'default') {\r\n                        timer.stopTimer();\r\n                        statusGame = 'pause';\r\n                        popup.querySelector(\".timeGame\").innerText = timer.getTime();\r\n                    }\r\n\r\n                    popup.classList.add('open');\r\n                    //Устранение дергания при убирании скрола\r\n                    const lockPaddingValue = window.innerWidth - document.body.offsetWidth + 'px';\r\n                    document.body.style.paddingRight = lockPaddingValue;\r\n                    document.body.style.overflow = \"hidden\";\r\n                    const header = document.querySelector(\"header\");\r\n                    if (header) {\r\n                        header.style.paddingRight = lockPaddingValue;\r\n                    }\r\n\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    //Обработчик опускания клавиши\r\n    document.addEventListener(\"keyup\", (e) => {\r\n        if (state != \"fall\" && state != \"jump\" && state != \"hit\" && state != \"hurt\" && state != \"death\")\r\n            changeAnimate(\"stand\");\r\n    });\r\n\r\n\r\n    //передвижение мира\r\n    function moveWorldRight() {\r\n        allObjects.style.left = Number.parseInt(allObjects.style.left) - speed + \"px\";\r\n        tileArray.map((elem) => {\r\n            elem[0] = elem[0] - 1 / (32 / speed);\r\n        });\r\n        AllEnemy.map((elem) => {\r\n            elem.moveRight();\r\n        });\r\n    }\r\n    function moveWorldLeft() {\r\n        allObjects.style.left = Number.parseInt(allObjects.style.left) + speed + \"px\";\r\n        tileArray.map((elem) => {\r\n            elem[0] = elem[0] + 1 / (32 / speed);\r\n        });\r\n        AllEnemy.map((elem) => {\r\n            elem.moveLeft();\r\n        });\r\n    }\r\n\r\n\r\n    //ФУнкция передвижения главного героя вправо\r\n    function rightHandler() {\r\n\r\n        heroImg.style.top = \"0px\";\r\n        heroImg.style.transform = \"scale(1, 1)\";\r\n        direction = \"right\";\r\n\r\n        animation = setInterval(() => {\r\n            leftPosMainHero <= -heroBlockSize * (MaxBlocksXHero - 1) ? leftPosMainHero = 0 : leftPosMainHero -= heroBlockSize;\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, 60);\r\n\r\n        animationSome = setInterval(() => {\r\n            if (checkAhead()) {\r\n                /* translateMainHero >= 2000 ? null : translateMainHero += speed;\r\n                hero.style.left = translateMainHero + \"px\"; */\r\n\r\n                moveWorldRight();\r\n\r\n                checkFalling();\r\n                if (isFalling)\r\n                    changeAnimate(\"fall\");\r\n\r\n                if (isRightSideBlocked) {\r\n                    changeAnimate(\"stand\");\r\n                }\r\n            }\r\n        }, 17);\r\n\r\n    }\r\n    //передвижение влево\r\n    function leftHandler() {\r\n\r\n        heroImg.style.top = \"0px\";\r\n        heroImg.style.transform = \"scale(-1, 1)\";\r\n        direction = \"left\";\r\n\r\n        animation = setInterval(() => {\r\n            leftPosMainHero >= 0 ? leftPosMainHero = -heroBlockSize * (MaxBlocksXHero - 1) : leftPosMainHero += heroBlockSize;\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, 60);\r\n\r\n        animationSome = setInterval(() => {\r\n            if (checkAhead() && !isLeftSideBlocked && Number.parseInt(allObjects.style.left) < 0) {\r\n                moveWorldLeft();\r\n                checkFalling();\r\n                if (isFalling)\r\n                    changeAnimate(\"fall\");\r\n            }\r\n        }, 17);\r\n    }\r\n    //анимация стоянки\r\n    function standHanlder() {\r\n        animation = setInterval(() => {\r\n            if (direction === \"right\") {\r\n                leftPosMainHero <= -heroBlockSize ? leftPosMainHero = 0 : leftPosMainHero -= heroBlockSize;\r\n                heroImg.style.transform = \"scale(1, 1)\";\r\n            } else {\r\n                leftPosMainHero >= -((MaxBlocksXHero - 1) * heroBlockSize - heroBlockSize) ? leftPosMainHero = -(MaxBlocksXHero - 1) * heroBlockSize : leftPosMainHero += heroBlockSize;\r\n                heroImg.style.transform = \"scale(-1, 1)\";\r\n            }\r\n\r\n            heroImg.style.top = \"-\" + heroBlockSize + \"px\";\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, 100);\r\n    }\r\n    //Удар\r\n    function hitHandler() {\r\n        heroImg.style.top = -heroBlockSize * 3 + \"px\";\r\n        if (direction === \"right\") {\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n            heroImg.style.left = \"0px\";\r\n            leftPosMainHero = 0;\r\n\r\n            animation = setInterval(() => {\r\n                if (leftPosMainHero <= -heroBlockSize * 5) {\r\n                    changeAnimate(\"stand\");\r\n                } else {\r\n                    leftPosMainHero -= heroBlockSize;\r\n                    heroImg.style.left = leftPosMainHero + \"px\";\r\n                }\r\n            }, 150);\r\n            setTimeout(() => {\r\n                fish = new Fish();\r\n            }, 150 * 4);\r\n\r\n        } else {\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n            heroImg.style.left = -(MaxBlocksXHero * heroBlockSize - 6 * heroBlockSize) + \"px\";\r\n            leftPosMainHero = -(MaxBlocksXHero * heroBlockSize - 6 * heroBlockSize);\r\n\r\n            animation = setInterval(() => {\r\n                if (leftPosMainHero <= -(MaxBlocksXHero - 1) * heroBlockSize) {\r\n                    changeAnimate(\"stand\");\r\n                } else {\r\n                    leftPosMainHero -= heroBlockSize;\r\n                    heroImg.style.left = leftPosMainHero + \"px\";\r\n                }\r\n            }, 150);\r\n            setTimeout(() => {\r\n                fish = new Fish();\r\n            }, 150 * 4);\r\n        }\r\n\r\n\r\n\r\n    }\r\n    class Fish {\r\n        x = heroX + 1;\r\n        fishXPos = this.x * 32;\r\n        flightDistance = 300;\r\n        y = heroY;\r\n        animation;\r\n        fish;\r\n        blockSize = 75;\r\n        constructor() {\r\n            this.createFish();\r\n            this.animateFish();\r\n        }\r\n\r\n        createFish() {\r\n            this.fish = document.createElement(\"div\");\r\n            const image = document.createElement(\"img\");\r\n\r\n            this.fish.style.cssText = `\r\n                position: absolute;\r\n                left: ${this.x * 32}px;\r\n                bottom: ${this.y * 32}px;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n            `;\r\n            game.appendChild(this.fish);\r\n\r\n            image.src = \"img/fish.png\";\r\n            image.style.cssText = `\r\n                position: absolute;\r\n                left: 0;\r\n                bottom: 0;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n            `;\r\n            if (direction === 'left') {\r\n                image.style.transform = \"scale(-1, 1)\";\r\n            }\r\n            this.fish.appendChild(image);\r\n        }\r\n\r\n        animateFish() {\r\n            const startPosXFish = this.fishXPos;\r\n\r\n            if (direction === 'right') {\r\n                this.animation = setInterval(() => {\r\n                    this.fishXPos += speed * 1.5;\r\n                    this.fish.style.left = this.fishXPos + \"px\";\r\n                    if (this.fishXPos > startPosXFish + this.flightDistance || checkFishToEnemy(this.fishXPos)) {\r\n                        clearInterval(this.animation);\r\n                        this.fish.parentNode.removeChild(this.fish);\r\n                        delete this;\r\n                    }\r\n                }, 17);\r\n            } else {\r\n                this.animation = setInterval(() => {\r\n                    this.fishXPos -= speed * 1.5;\r\n                    this.fish.style.left = this.fishXPos + \"px\";\r\n                    if (this.fishXPos < startPosXFish - this.flightDistance || checkFishToEnemy(this.fishXPos)) {\r\n                        clearInterval(this.animation);\r\n                        this.fish.parentNode.removeChild(this.fish);\r\n                        delete this;\r\n                    }\r\n                }, 17);\r\n            }\r\n\r\n\r\n\r\n        }\r\n    }\r\n\r\n    //Прыжок\r\n    function jumpHandler() {\r\n        topMainHero = heroY * 32;\r\n        const startPosY = topMainHero;\r\n        //картинка прышка\r\n        heroImg.style.top = -heroBlockSize * 2 + \"px\";\r\n\r\n        //установка изначального положения спрайта\r\n        if (direction === \"right\") {\r\n            heroImg.style.left = \"0px\";\r\n            leftPosMainHero = 0;\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n        }\r\n        else {\r\n            heroImg.style.left = -heroBlockSize * MaxBlocksXHero + \"px\";\r\n            leftPosMainHero = -heroBlockSize * (MaxBlocksXHero - 1);\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n        }\r\n\r\n        animationSome = setInterval(() => {\r\n            if (direction === \"right\") {\r\n                leftPosMainHero <= -heroBlockSize * 3 ? leftPosMainHero = 0 : leftPosMainHero -= heroBlockSize;\r\n            } else {\r\n                leftPosMainHero >= -(MaxBlocksXHero - heroBlockSize * 3) ? leftPosMainHero = -heroBlockSize * MaxBlocksXHero : leftPosMainHero += heroBlockSize;\r\n            }\r\n\r\n            heroImg.style.left = leftPosMainHero + \"px\";\r\n        }, heightJump / 10 * 17 / 3);\r\n\r\n        //передвижение персонажа\r\n        animation = setInterval(() => {\r\n            topMainHero += speed;\r\n\r\n            if (!checkSoffit()) {\r\n                changeAnimate(\"fall\");\r\n            }\r\n\r\n            if (topMainHero - startPosY > heightJump) {\r\n                checkFalling();\r\n                if (isFalling) {\r\n                    changeAnimate(\"fall\");\r\n                }\r\n                else {\r\n                    hero.style.bottom = `${heroY * 32}px`;\r\n                    changeAnimate(\"stand\");\r\n                }\r\n            } else {\r\n                hero.style.bottom = topMainHero + \"px\";\r\n            }\r\n\r\n            if (direction === \"right\") {\r\n                /* translateMainHero += speed;\r\n                hero.style.left = translateMainHero + \"px\"; */\r\n\r\n                moveWorldRight();\r\n            } else if (Number.parseInt(allObjects.style.left) < 0) {\r\n                /* translateMainHero -= speed;\r\n                hero.style.left = translateMainHero + \"px\"; */\r\n\r\n                moveWorldLeft();\r\n            }\r\n\r\n        }, 17);\r\n    }\r\n    function fallHandler() {\r\n\r\n        heroImg.style.top = -(heroBlockSize * 2) + \"px\";\r\n        if (direction === \"right\") {\r\n            leftPosMainHero = -(heroBlockSize * 2);\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n        } else {\r\n            leftPosMainHero = -(heroBlockSize * 3);\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n        }\r\n\r\n\r\n        animation = setInterval(() => {\r\n            topMainHero -= speed;\r\n            hero.style.bottom = topMainHero + \"px\";\r\n            checkFalling();\r\n            if (!isFalling) {\r\n                hero.style.bottom = `${heroY * 32}px`;\r\n                changeAnimate(\"stand\");\r\n            }\r\n        }, 17);\r\n\r\n\r\n        heroImg.style.left = leftPosMainHero + \"px\";\r\n\r\n\r\n    }\r\n    function hurtHanlder() {\r\n        heroImg.style.top = -heroBlockSize * 4 + \"px\";\r\n        if (direction === \"right\") {\r\n            heroImg.style.left = \"0px\";\r\n        } else {\r\n            heroImg.style.left = -(MaxBlocksXHero - 1) * heroBlockSize + \"px\";\r\n        }\r\n\r\n        killHeart();\r\n       \r\n\r\n        setTimeout(() => {\r\n            if (lives <= 0)\r\n                changeAnimate(\"death\");\r\n            else\r\n                changeAnimate(\"stand\");\r\n        }, 100);\r\n    }\r\n    function deathHanlder() {\r\n        heroImg.style.top = -heroBlockSize * 5 + \"px\";\r\n        if (direction === \"right\") {\r\n            heroImg.style.transform = \"scale(1, 1)\";\r\n            heroImg.style.left = \"0px\";\r\n            leftPosMainHero = 0;\r\n\r\n            animation = setInterval(() => {\r\n                if (leftPosMainHero <= -heroBlockSize * 4) {\r\n                    //конец игры\r\n                    changeAnimate(\"dsfsf\");\r\n                    gameOver(\"loss\");\r\n                    statusGame = \"loss\";\r\n                } else {\r\n                    leftPosMainHero -= heroBlockSize;\r\n                    heroImg.style.left = leftPosMainHero + \"px\";\r\n                }\r\n            }, 150);\r\n\r\n        } else {\r\n            heroImg.style.transform = \"scale(-1, 1)\";\r\n            heroImg.style.left = -(MaxBlocksXHero * heroBlockSize - 4 * heroBlockSize) + \"px\";\r\n            leftPosMainHero = -(MaxBlocksXHero * heroBlockSize - 4 * heroBlockSize);\r\n\r\n            animation = setInterval(() => {\r\n                if (leftPosMainHero >= -(MaxBlocksXHero - 5) * heroBlockSize) {\r\n                    //конец игры\r\n                    changeAnimate(\"dsfsf\");\r\n                    gameOver(\"loss\");\r\n                    statusGame = \"loss\";\r\n                } else {\r\n                    leftPosMainHero += heroBlockSize;\r\n                    heroImg.style.left = leftPosMainHero + \"px\";\r\n                }\r\n            }, 150);\r\n        }\r\n    }\r\n\r\n\r\n    function createTile(x, y = 1) {\r\n        const tile = document.createElement(\"img\");\r\n        tile.src = \"img/tiles/main.jpeg\";\r\n        tile.style.cssText = `\r\n            position: absolute;\r\n            left: ${x * 32}px;\r\n            bottom: ${y * 32}px;\r\n            width: 32px;\r\n            height: 32px;\r\n        `;\r\n        allObjects.appendChild(tile);\r\n\r\n        tileArray.push([x, y]);\r\n        //objectsArray.push(tile);\r\n    }\r\n    function addTiles(i) {\r\n        createTile(i);\r\n\r\n        const tileBottom = document.createElement(\"img\");\r\n        tileBottom.src = \"img/tiles/foundation.jpeg\";\r\n        tileBottom.style.cssText = `\r\n            position: absolute;\r\n            left: ${i * 32}px;\r\n            bottom: 0;\r\n            width: 32px;\r\n            height: 32px;\r\n        `;\r\n        allObjects.appendChild(tileBottom);\r\n        //objectsArray.push(tileBottom);\r\n    }\r\n    function createTilesPlatform(startX, startY, lenght) {\r\n        for (let i = 0; i < lenght; i++) {\r\n            createTile(startX + i, startY);\r\n        }\r\n    }\r\n\r\n    function updateHeroY() {\r\n        //heroX = Math.ceil(Number.parseInt(getComputedStyle(hero).left) / 32);\r\n        heroY = Math.ceil(Number.parseInt(getComputedStyle(hero).bottom) / 32);\r\n    }\r\n\r\n    //проверка должен ли персонаж падать\r\n    function checkFalling() {\r\n        updateHeroY();\r\n        isFalling = true;\r\n        for (let i = 0; i < tileArray.length; i++) {\r\n            if (heroY <= -3) {\r\n                gameOver(\"loss\");\r\n                statusGame = \"loss\";\r\n                changeAnimate(\"fdsf\");\r\n            }\r\n            if (Math.ceil(tileArray[i][0]) === heroX && Math.ceil(tileArray[i][1]) + 1 === heroY) {\r\n                isFalling = false;\r\n                break;\r\n            } else if (Math.ceil(tileArray[i][0]) === heroX + 3 && Math.ceil(tileArray[i][1]) + 1 === heroY) {\r\n                isFalling = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    //проверка может ли персонаж идти (есть ли стенка впереди)\r\n    function checkAhead() {\r\n        updateHeroY();\r\n        if (direction === \"right\") {\r\n            for (let i = 0; i < tileArray.length; i++) {\r\n                if (Math.ceil(tileArray[i][0]) === heroX + 3 && Math.ceil(tileArray[i][1]) + 1 === heroY + 1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < tileArray.length; i++) {\r\n                if (Math.ceil(tileArray[i][0]) === heroX && Math.ceil(tileArray[i][1]) + 1 === heroY + 1) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    //проверка задевает ли рыба монстра\r\n    function checkFishToEnemy(FishX) {\r\n        updateHeroY();\r\n        FishX = Math.ceil(FishX / 32);\r\n        let isTrue = false;\r\n\r\n        arrayEnemies.forEach(Enemy => {\r\n            if (Enemy.state != Enemy.DEATH) {\r\n                if (Math.ceil(Enemy.posX) === FishX && Math.ceil(Enemy.posY) === heroY) {\r\n                    if (Enemy.lives <= 1) {\r\n                        Enemy.changeAnimate(Enemy.DEATH);\r\n                    } else {\r\n                        Enemy.changeAnimate(Enemy.HURT);\r\n                        Enemy.showHurt();\r\n                        Enemy.lives--;\r\n                    }\r\n                    isTrue = true;\r\n                    return true;\r\n                }\r\n            }\r\n        });\r\n        if (isTrue)\r\n            return true;\r\n        else return false;\r\n    }\r\n    //проверка может ли персонаж лететь вверх (есть ли потолок потолок)\r\n    function checkSoffit() {\r\n        updateHeroY();\r\n        if (direction === \"right\") {\r\n            for (let i = 0; i < tileArray.length; i++) {\r\n                if (Math.ceil(tileArray[i][0]) === heroX + 2 && Math.ceil(tileArray[i][1]) + 1 === heroY + 2) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < tileArray.length; i++) {\r\n                if (Math.ceil(tileArray[i][0]) === heroX + 1 && Math.ceil(tileArray[i][1]) + 1 === heroY + 2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function lifeCycle() {\r\n        lifeCycleTimer = setInterval(() => {\r\n            if (animateWasChanged) {\r\n                animateWasChanged = false;\r\n                if (state === \"fall\") {\r\n                    fallHandler();\r\n                } else if (state === \"stand\") {\r\n                    standHanlder();\r\n                } else if (state === \"hurt\") {\r\n                    hurtHanlder();\r\n                } else if (state === \"death\") {\r\n                    deathHanlder();\r\n                }\r\n            }\r\n        }, 17);\r\n    }\r\n\r\n    function start() {\r\n\r\n        //!первой строкой можно добавить загрузку, последней ее удаление\r\n        lifeCycle();\r\n        \r\n        new generateMap();\r\n\r\n    }\r\n\r\n    //Класс для генерации врага\r\n    class Enemy {\r\n\r\n        STAND = \"stand\";\r\n        ATTACK = \"attack\";\r\n        DEATH = \"death\";\r\n        WALK = \"walk\";\r\n        HURT = \"hurt\";\r\n\r\n        posX;\r\n        posY;\r\n        startX;\r\n        travelInterval = 6;\r\n        direction = .1;\r\n        img;\r\n        block;\r\n        blockSize = 96;\r\n        timer;\r\n        animation;\r\n        animationSome;\r\n        state = \"stand\";\r\n        attack = false;\r\n        animateWasChanged = true;\r\n        isHurt = false;\r\n\r\n        SpriteMaxPosX = 6;\r\n        SpriteMaxPosY = 5;\r\n        SpritePosX = 0;\r\n        SpritePosY = 0;\r\n\r\n        NumPosStand = 2;\r\n        NumPosHurt = 1;\r\n        NumPosWalk = 5;\r\n        NumPosAttack = 3;\r\n        NUmPosDeath = 4;\r\n\r\n        lives = 2;\r\n\r\n        constructor(x, y) {\r\n            this.posX = x;\r\n            this.posY = y;\r\n            this.startX = this.posX;\r\n\r\n            this.createEnimy();\r\n\r\n            AllEnemy.push(this);\r\n\r\n            this.lifeCycle();\r\n\r\n            this.changeAnimate(this.WALK);\r\n\r\n            this.updatePositionX();\r\n        }\r\n\r\n        createEnimy() {\r\n            this.block = document.createElement('div');\r\n            this.block.style.cssText = `\r\n                position: absolute;\r\n                left: ${this.posX * 32}px;\r\n                bottom: ${this.posY * 32}px;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n            `;\r\n            game.appendChild(this.block);\r\n            this.img = document.createElement(\"img\");\r\n            this.img.src = \"img/characters/enemies/StandDog.svg\";\r\n            this.img.style.cssText = `\r\n                position: absolute;\r\n                left: 0;\r\n                bottom: 0;\r\n                width: ${this.blockSize * this.SpriteMaxPosX}px;\r\n                height: ${this.blockSize * this.SpriteMaxPosY}px;\r\n            `;\r\n            this.block.appendChild(this.img);\r\n        }\r\n\r\n        lifeCycle() {\r\n            this.timer = setInterval(() => {\r\n                this.checkCollide();\r\n                if (this.animateWasChanged) {\r\n                    this.animateWasChanged = false;\r\n                    switch (this.state) {\r\n                        case this.DEATH:\r\n                            this.deathAnimate();\r\n                            break;\r\n                        case this.HURT:\r\n                            this.hurtAnimate();\r\n                            break;\r\n                        case this.WALK:\r\n                            this.walkAnimate();\r\n                            break;\r\n                        case this.STAND:\r\n                            this.standAnimate();\r\n                            break;\r\n                        case this.ATTACK:\r\n                            this.attackAnimate();\r\n                            break;\r\n                        case this.DEATH:\r\n                            this.deathAnimate();\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            }, 17);\r\n        }\r\n\r\n        updatePositionX() {\r\n            setInterval(() => {\r\n                this.block.style.left = this.posX * 32 + \"px\";\r\n            });\r\n        }\r\n\r\n        //Проверка столкновения с героем\r\n        checkCollide() {\r\n\r\n            if (heroY == this.posY) {\r\n                if (heroX == Math.floor(this.posX)) {\r\n                    isRightSideBlocked = true;\r\n                    isLeftSideBlocked = false;\r\n                    if (state === \"hit\" && this.state != this.HURT && !this.isHurt) {\r\n                        //! убрал получение урона при ситуации, когда герой и монстр столкнулись и герой атакует, так как это делается на рыбе\r\n                        /* this.isHurt = true; */\r\n                        //получение урона делаем только через время, так как сначала дожна пройти анимация атаки кота,\r\n                        //иначе будет многократное получение урона\r\n                        /* setTimeout(() => {\r\n                            this.changeAnimate(this.HURT);\r\n                            this.showHurt();\r\n                            this.lives--;\r\n                        }, 600); */\r\n                    } else if (!this.attack) {\r\n                        this.changeAnimate(this.ATTACK);\r\n                    }\r\n                } else if (heroX == Math.floor(this.posX + 2) || heroX == Math.floor(this.posX + 1)) {\r\n                    isLeftSideBlocked = true;\r\n                    isRightSideBlocked = false;\r\n                    if (state === \"hit\" && this.state != this.HURT && !this.isHurt) {\r\n                        //! убрал получение урона при ситуации, когда герой и монстр столкнулись и герой атакует, так как это делается на рыбе\r\n                        /* this.isHurt = true; */\r\n                        //получение урона делаем только через время, так как сначала дожна пройти анимация атаки кота,\r\n                        //иначе будет многократное получение урона\r\n                        /* setTimeout(() => {\r\n                            this.changeAnimate(this.HURT);\r\n                            this.showHurt();\r\n                            this.lives--;\r\n                        }, 600); */\r\n                    } else if (!this.attack) {\r\n                        this.changeAnimate(this.ATTACK);\r\n                    }\r\n                } else if (this.state === this.ATTACK) {\r\n                    this.changeAnimate(this.WALK);\r\n                    this.attack = false;\r\n\r\n                    isLeftSideBlocked = false;\r\n                    isRightSideBlocked = false;\r\n                }\r\n            } else if (this.state === this.ATTACK) {\r\n                this.changeAnimate(this.WALK);\r\n                this.attack = false;\r\n\r\n                isLeftSideBlocked = false;\r\n                isRightSideBlocked = false;\r\n            }\r\n        }\r\n\r\n        changeAnimate(stateStr) {\r\n            clearInterval(this.animation);\r\n            this.animation = null;\r\n            clearInterval(this.animationSome);\r\n            this.animationSome = null;\r\n\r\n            this.state = stateStr;\r\n            this.animateWasChanged = true;\r\n        }\r\n\r\n        standAnimate() {\r\n            this.img.style.top = \"0px\";\r\n            this.img.style.left = \"0px\";\r\n            this.SpritePosX = 1;\r\n            this.animation = setInterval(() => {\r\n\r\n                if (this.direction === Math.abs(this.direction)) {\r\n                    this.img.style.transform = \"scale(-1, 1)\";\r\n\r\n                    if (-this.SpritePosX * this.blockSize >= (-(this.SpriteMaxPosX - 1 - this.NumPosStand) * this.blockSize)) {\r\n                        this.SpritePosX = this.SpriteMaxPosX;\r\n                    } else {\r\n                        this.SpritePosX--;\r\n                        this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                    }\r\n                } else {\r\n                    this.img.style.transform = \"scale(1, 1)\";\r\n\r\n                    this.SpritePosX === this.NumPosStand ? this.SpritePosX = 0 : this.SpritePosX++;\r\n                    this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                }\r\n            }, 100);\r\n        }\r\n\r\n        walkAnimate() {\r\n            this.img.style.top = -this.blockSize * 4 + \"px\";\r\n            this.img.style.left = \"0px\";\r\n            this.SpritePosX = 1;\r\n            this.animationSome = setInterval(() => {\r\n                if (this.posX > this.startX + this.travelInterval) {\r\n                    this.direction *= -1;\r\n                    this.img.style.transform = \"scale(1, 1)\";\r\n                }\r\n                else if (this.posX <= this.startX) {\r\n                    this.direction = Math.abs(this.direction);\r\n                    this.img.style.transform = \"scale(-1, 1)\";\r\n                }\r\n\r\n                this.posX += this.direction;\r\n                this.block.style.left = this.posX * 32 + \"px\";\r\n            }, 17);\r\n            this.animation = setInterval(() => {\r\n                this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                this.SpritePosX === this.NumPosWalk ? this.SpritePosX = 0 : this.SpritePosX++;\r\n            }, 100);\r\n        }\r\n\r\n        attackAnimate() {\r\n            this.attack = true;\r\n            this.img.style.top = this.blockSize * -2 + \"px\";\r\n            this.img.style.left = \"0px\";\r\n\r\n            this.SpritePosX = 0;\r\n\r\n            this.animation = setInterval(() => {\r\n                if (this.direction === Math.abs(this.direction)) {\r\n                    this.img.style.transform = \"scale(-1, 1)\";\r\n\r\n                    if (-this.SpritePosX * this.blockSize >= (-(this.SpriteMaxPosX - 1 - this.NumPosAttack) * this.blockSize)) {\r\n                        this.SpritePosX = this.SpriteMaxPosX;\r\n\r\n                        if (state != \"jump\" && state != \"fall\") {\r\n                            changeAnimate(\"hurt\");\r\n\r\n                            if (lives <= 1) {\r\n                                this.changeAnimate(this.STAND);\r\n                            }\r\n                        }\r\n\r\n                    } else {\r\n                        this.SpritePosX--;\r\n                        this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                    }\r\n                } else {\r\n                    this.img.style.transform = \"scale(1, 1)\";\r\n                    if (this.SpritePosX >= this.NumPosAttack) {\r\n                        this.SpritePosX = 0;\r\n\r\n                        if (state != \"jump\" && state != \"fall\") {\r\n                            changeAnimate(\"hurt\");\r\n\r\n                            if (lives <= 1) {\r\n                                this.changeAnimate(this.STAND);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        this.SpritePosX++;\r\n                        this.img.style.left = -(this.SpritePosX * this.blockSize) + \"px\";\r\n                    }\r\n                }\r\n\r\n            }, 150);\r\n        }\r\n\r\n        deathAnimate() {\r\n            this.img.style.top = -1 * this.blockSize + \"px\";\r\n\r\n            //если повернут влево(по умолчанию)\r\n            if (this.direction === Math.abs(this.direction)) {\r\n                this.img.style.transform = \"scale(-1, 1)\";\r\n                this.img.style.left = -(this.SpriteMaxPosX - this.NUmPosDeath * this.blockSize) + \"px\";\r\n                this.posXSprite = this.SpriteMaxPosX + 2 - this.NUmPosDeath;\r\n\r\n                this.animation = setInterval(() => {\r\n                    if (this.posXSprite < 2) {\r\n                        clearInterval(this.animation);\r\n                        //смерть\r\n                        //this.block.style.display = \"none\";\r\n                        //clearInterval(animation);\r\n                        //this.changeAnimate(this.STAND);\r\n                    } else {\r\n                        this.img.style.left = -this.posXSprite * this.blockSize + \"px\";\r\n                        this.posXSprite--;\r\n                    }\r\n                }, 100);\r\n\r\n                //если повернут вправо\r\n            } else {\r\n                this.img.style.transform = \"scale(1, 1)\";\r\n                this.img.style.left = \"0px\";\r\n                this.posXSprite = 0;\r\n\r\n                this.animation = setInterval(() => {\r\n                    if (this.posXSprite > this.NUmPosDeath) {\r\n                        clearInterval(this.animation);\r\n                        //смерть\r\n                        //this.block.style.display = \"none\";\r\n                        //(animation);\r\n                        //this.changeAnimate(this.STAND);\r\n                    } else {\r\n                        this.img.style.left = -this.posXSprite * this.blockSize + \"px\";\r\n                        this.posXSprite++;\r\n                    }\r\n                }, 100);\r\n            }\r\n\r\n            clearInterval(this.timer);\r\n            isLeftSideBlocked = false;\r\n            isRightSideBlocked = false;\r\n\r\n            /* allObjects.appendChild(this.block);\r\n            AllEnemy = AllEnemy.filter(item => item !== this); */\r\n\r\n\r\n        }\r\n\r\n        hurtAnimate() {\r\n\r\n            this.img.style.top = -3 * this.blockSize + \"px\";\r\n            if (this.direction === Math.abs(this.direction)) {\r\n                this.img.style.transform = \"scale(-1, 1)\";\r\n                this.img.style.left = -(this.SpriteMaxPosX - this.NumPosHurt) * this.blockSize + \"px\";\r\n            } else {\r\n                this.img.style.transform = \"scale(1, 1)\";\r\n                this.img.style.left = -this.NumPosHurt * this.blockSize + \"px\";\r\n            }\r\n\r\n            setTimeout(() => {\r\n                this.isHurt = false;\r\n                if (this.lives <= 0) {\r\n                    this.changeAnimate(this.DEATH);\r\n                } else {\r\n                    this.changeAnimate(this.ATTACK);\r\n                }\r\n            }, 300);\r\n\r\n        }\r\n\r\n        //отображение урона\r\n        showHurt() {\r\n            const element = document.createElement(\"p\");\r\n            element.innerText = \"-1\";\r\n            element.style.cssText = `\r\n                color: red;\r\n                font-weight: 700;\r\n                font-size: 30px;\r\n                text-shadow: 1px 1px 2px #000;\r\n                position: absolute;\r\n                animation: showHurt 1s ease;\r\n                left: ${Number.parseInt(this.block.style.left + 50)}px;\r\n                bottom: ${Number.parseInt(this.block.style.bottom + 32)}px;\r\n            `;\r\n            game.appendChild(element);\r\n\r\n            setTimeout(() => {\r\n                element.parentNode.removeChild(element);\r\n            }, 1000);\r\n        }\r\n\r\n        //для смены координат при движении камеры\r\n        moveRight() {\r\n            this.startX -= 1 / (32 / speed);\r\n            this.posX -= 1 / (32 / speed);\r\n        }\r\n        moveLeft() {\r\n            this.startX += 1 / (32 / speed);\r\n            this.posX += 1 / (32 / speed);\r\n        }\r\n    }\r\n\r\n    //Класс для работы с таймером\r\n    class Timer {\r\n        seconds = 0;\r\n        minutes = 0;\r\n        elementMinites = document.querySelector(\"#minutes\");\r\n        elementSeconds = document.querySelector(\"#seconds\");\r\n        ticking;\r\n\r\n        constructor() {\r\n            this.startTimer();\r\n        }\r\n\r\n        stopTimer() {\r\n            clearInterval(this.ticking);\r\n        }\r\n\r\n        startTimer() {\r\n            clearInterval(this.ticking);\r\n            this.ticking = setInterval(() => {\r\n                this.seconds++;\r\n                if (this.seconds === 60) {\r\n                    this.seconds = 0;\r\n                    this.minutes++;\r\n                }\r\n\r\n                if (this.minutes < 10)\r\n                    this.elementMinites.innerText = \"0\" + this.minutes;\r\n                else this.elementMinites.innerText = this.minutes;\r\n\r\n                if (this.seconds < 10)\r\n                    this.elementSeconds.innerText = \"0\" + this.seconds;\r\n                else this.elementSeconds.innerText = this.seconds;\r\n            }, 1000);\r\n        }\r\n\r\n        getTime() {\r\n            let sec;\r\n            let min;\r\n\r\n            if (this.minutes < 10)\r\n                min = \"0\" + this.minutes;\r\n            else min = this.minutes;\r\n\r\n            if (this.seconds < 10)\r\n                sec = \"0\" + this.seconds;\r\n            else sec = this.seconds;\r\n\r\n            return min + \":\" + sec;\r\n        }\r\n    }\r\n\r\n    class VictoryLodge {\r\n        posX;\r\n        posY;\r\n        block;\r\n\r\n        img;\r\n        imgSrc = \"img/VictoryLodge.png\";\r\n        spritePosX = 0;\r\n        blockSize = 250;\r\n        spriteMaxPosX = 7;\r\n        timeInterval = 100;\r\n\r\n        animation;\r\n\r\n        winPosX;\r\n\r\n        constructor(x, y) {\r\n            this.posX = x;\r\n            this.posY = y;\r\n            this.winPosX = Math.floor(this.blockSize / 2 / 32 + this.posX);\r\n\r\n            this.create();\r\n            this.animateStand();\r\n        }\r\n\r\n        checkWin() {\r\n            let checkWinTimer = setInterval(() => {\r\n                let currentPosX = Math.ceil(Number.parseInt(getComputedStyle(allObjects).left) / 32 + this.winPosX - heroX / 2);\r\n                if (currentPosX === heroX && this.posY === heroY) {\r\n                    gameOver(\"win\");\r\n                    statusGame = \"win\";\r\n                    clearInterval(checkWinTimer);\r\n                }\r\n\r\n            }, 50);\r\n        }\r\n\r\n        create() {\r\n            this.block = document.createElement(\"div\");\r\n            this.block.style.cssText = `\r\n                position: absolute;\r\n                bottom: ${this.posY * 32}px;\r\n                left: ${this.posX * 32}px;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n            `;\r\n\r\n            this.img = document.createElement(\"img\");\r\n            this.img.src = this.imgSrc;\r\n            this.img.style.cssText = `\r\n                position: absolute;\r\n                top: 0px;\r\n                left: ${this.spritePosX * this.blockSize}px;\r\n                width: ${this.blockSize * this.spriteMaxPosX}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n            `;\r\n\r\n            this.block.appendChild(this.img);\r\n            allObjects.appendChild(this.block);\r\n        }\r\n\r\n        animateWin() {\r\n            this.spritePosX = 0;\r\n            clearInterval(this.animation);\r\n            this.animation = setInterval(() => {\r\n                this.spritePosX++;\r\n                if (this.spritePosX === this.spriteMaxPosX)\r\n                    this.spritePosX = 0;\r\n                this.img.style.left = -this.spritePosX * this.blockSize + \"px\";\r\n            }, this.timeInterval);\r\n        }\r\n\r\n        animateStand() {\r\n            this.spritePosX = 0;\r\n            this.animation = setInterval(() => {\r\n                this.spritePosX++;\r\n                if (this.spritePosX === 3)\r\n                    this.spritePosX = 0;\r\n                this.img.style.left = -this.spritePosX * this.blockSize + \"px\";\r\n            }, this.timeInterval);\r\n        }\r\n\r\n    }\r\n\r\n    function gameOver(state) {\r\n        isGameNotOver = false;\r\n        changeAnimate(\"stand\");\r\n        timer.stopTimer();\r\n        if (state === \"win\") {\r\n            victoryLodge.animateWin();\r\n            document.querySelector(\".timeGame\").innerText = timer.getTime();\r\n            setTimeout(() => {\r\n                document.querySelector(\"[data-custom-popup='win']\").classList.add(\"open\");\r\n            }, victoryLodge.timeInterval * (victoryLodge.spriteMaxPosX - 1) * 2);\r\n\r\n            //Подсчет звезд\r\n            const ratio = lives / maxLives;\r\n            let starsLenght;\r\n            if (ratio <= .35)\r\n                starsLenght = 1;\r\n            else if (ratio <= .7)\r\n                starsLenght = 2;\r\n            else starsLenght = 3;\r\n\r\n            const starsElement = document.querySelector(\"#stars\");\r\n            for (let index = 0; index < starsLenght; index++) {\r\n                const star = document.createElement('img');\r\n                star.src = \"img/icons/star.png\";\r\n                star.alt = \"star\";\r\n                starsElement.appendChild(star);\r\n            }\r\n\r\n            //сохранение рейтинга\r\n            const localObj = localStorage.getItem(\"starsRaitingUser\");\r\n            const urlParams = new URLSearchParams(window.location.search);\r\n            const levelNum = parseInt(urlParams.get('level'));\r\n            if (localObj) {\r\n                const existingObject = JSON.parse(localObj);\r\n                const keyToAccess = 'l' + levelNum;\r\n                existingObject[keyToAccess] = starsLenght;\r\n                localStorage.setItem('starsRaitingUser', JSON.stringify(existingObject));\r\n            } else {\r\n                const existingObject = {}\r\n                const keyToAccess = 'l' + levelNum;\r\n                existingObject[keyToAccess] = starsLenght;\r\n                localStorage.setItem('starsRaitingUser', JSON.stringify(existingObject));\r\n            }\r\n\r\n        } else {\r\n            document.querySelector(\"[data-custom-popup='loss']\").classList.add(\"open\");\r\n        }\r\n    }\r\n\r\n    class generateDecor {\r\n        nameDecor;\r\n        src = 'img/decors/';\r\n        x;\r\n        y;\r\n        blockSize;\r\n\r\n        constructor(name, x, y) {\r\n            this.nameDecor = name;\r\n            this.x = x;\r\n            this.y = y;\r\n\r\n            this.definitionOfDecoration();\r\n\r\n            this.createDecor();\r\n        }\r\n        definitionOfDecoration() {\r\n            switch (this.nameDecor) {\r\n                case \"tree\":\r\n                    this.blockSize = 150;\r\n                    this.src += \"tree.png\";\r\n                    break;\r\n                case \"fountain\":\r\n                    this.blockSize = 100;\r\n                    this.src += \"fountain.png\";\r\n                    break;\r\n\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        createDecor() {\r\n            const decor = document.createElement(\"div\");\r\n            const image = document.createElement(\"img\");\r\n\r\n            decor.style.cssText = `\r\n                position: absolute;\r\n                left: ${this.x * 32}px;\r\n                bottom: ${this.y * 32}px;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n            `;\r\n            allObjects.appendChild(decor);\r\n\r\n            image.src = this.src;\r\n            image.style.cssText = `\r\n                position: absolute;\r\n                left: 0;\r\n                bottom: 0;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n            `;\r\n            decor.appendChild(image);\r\n        }\r\n    }\r\n\r\n\r\n    const levels = {\r\n        \"1\": {\r\n            \"lives\": 3,\r\n            \"mapLenght\": 50,\r\n            \"platforms\": {\r\n                \"1\": {\r\n                    \"x\": 13,\r\n                    \"y\": 6,\r\n                    \"length\": 10\r\n                }\r\n            },\r\n            \"buffs\": {\r\n\r\n            },\r\n            \"decors\": {\r\n                \"1\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 17,\r\n                    \"y\": 7\r\n                },\r\n                \"2\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 10,\r\n                    \"y\": 2\r\n                },\r\n                \"3\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 34,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"enemies\": {\r\n                \"1\": {\r\n                    \"x\": 35,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"victoryLodge\": {\r\n                \"x\": 40,\r\n                \"y\": 2\r\n            },\r\n            \"abysses\": {\r\n                \"2\": {\r\n                    \"x1\": 25,\r\n                    \"x2\": 30\r\n                }\r\n            }\r\n        },\r\n\r\n        \"2\": {\r\n            \"lives\": 3,\r\n            \"mapLenght\": 100,\r\n            \"platforms\": {\r\n                \"1\": {\r\n                    \"x\": 15,\r\n                    \"y\": 5,\r\n                    \"length\": 9\r\n                },\r\n                \"2\": {\r\n                    \"x\": 25,\r\n                    \"y\": 8,\r\n                    \"length\": 5\r\n                },\r\n                \"3\": {\r\n                    \"x\": 105,\r\n                    \"y\": 5,\r\n                    \"length\": 6\r\n                }\r\n            },\r\n            \"buffs\": {\r\n            },\r\n            \"decors\": {\r\n                \"1\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 40,\r\n                    \"y\": 2\r\n                },\r\n                \"2\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 25,\r\n                    \"y\": 9\r\n                },\r\n                \"3\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 70,\r\n                    \"y\": 2\r\n                },\r\n                \"4\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 77,\r\n                    \"y\": 2\r\n                },\r\n                \"5\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 85,\r\n                    \"y\": 2\r\n                },\r\n\r\n                \"6\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 90,\r\n                    \"y\": 2\r\n                },\r\n                \"1.1\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 15,\r\n                    \"y\": 6\r\n                },\r\n                \"1.2\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 34,\r\n                    \"y\": 2\r\n                },\r\n                \"1.3\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 65,\r\n                    \"y\": 2\r\n                },\r\n                \"1.4\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 47,\r\n                    \"y\": 2\r\n                },\r\n                \"1.5\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 56,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"enemies\": {\r\n                \"1\": {\r\n                    \"x\": 34,\r\n                    \"y\": 2\r\n                },\r\n                \"2\": {\r\n                    \"x\": 15,\r\n                    \"y\": 6\r\n                },\r\n                \"3\": {\r\n                    \"x\": 70,\r\n                    \"y\": 2\r\n                },\r\n                \"4\": {\r\n                    \"x\": 80,\r\n                    \"y\": 2\r\n                }\r\n\r\n            },\r\n            \"victoryLodge\": {\r\n                \"x\": 105,\r\n                \"y\": 6\r\n            },\r\n            \"abysses\": {\r\n                \"1\": {\r\n                    \"x1\": 10,\r\n                    \"x2\": 34\r\n                },\r\n                \"2\": {\r\n                    \"x1\": 50,\r\n                    \"x2\": 55\r\n                },\r\n                \"3\": {\r\n                    \"x1\": 60,\r\n                    \"x2\": 65\r\n                }\r\n\r\n            }\r\n        },\r\n        \"3\": {\r\n            \"lives\": 4,\r\n            \"mapLenght\": 150,\r\n            \"platforms\": {\r\n                \"1\": {\r\n                    \"x\": 10,\r\n                    \"y\": 6,\r\n                    \"length\": 10\r\n                }\r\n            },\r\n            \"decors\": {\r\n                \"1\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 10,\r\n                    \"y\": 10\r\n                },\r\n                \"2\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 10,\r\n                    \"y\": 10\r\n                }\r\n            },\r\n            \"buffs\": {\r\n                \"1\": {\r\n                    \"name\": \"heart\",\r\n                    \"x\": 10,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"enemies\": {\r\n                \"1\": {\r\n                    \"x\": 35,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"victoryLodge\": {\r\n                \"x\": 10,\r\n                \"y\": 2\r\n            },\r\n            \"abysses\": {\r\n                \"2\": {\r\n                    \"x1\": 25,\r\n                    \"x2\": 30\r\n                }\r\n            }\r\n        },\r\n        \"4\": {\r\n            \"lives\": 4,\r\n            \"mapLenght\": 50,\r\n            \"platforms\": {\r\n                \"1\": {\r\n                    \"x\": 10,\r\n                    \"y\": 6,\r\n                    \"length\": 10\r\n                }\r\n            },\r\n            \"decors\": {\r\n                \"1\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 10,\r\n                    \"y\": 10\r\n                },\r\n                \"2\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 10,\r\n                    \"y\": 10\r\n                }\r\n            },\r\n            \"buffs\": {\r\n                \"1\": {\r\n                    \"name\": \"heart\",\r\n                    \"x\": 10,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"enemies\": {\r\n                \"1\": {\r\n                    \"x\": 35,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"victoryLodge\": {\r\n                \"x\": 10,\r\n                \"y\": 2\r\n            },\r\n            \"abysses\": {\r\n                \"2\": {\r\n                    \"x1\": 25,\r\n                    \"x2\": 30\r\n                }\r\n            }\r\n        },\r\n        \"5\": {\r\n            \"lives\": 4,\r\n            \"mapLenght\": 50,\r\n            \"platforms\": {\r\n                \"1\": {\r\n                    \"x\": 10,\r\n                    \"y\": 6,\r\n                    \"length\": 10\r\n                }\r\n            },\r\n            \"decors\": {\r\n                \"1\": {\r\n                    \"name\": \"tree\",\r\n                    \"x\": 10,\r\n                    \"y\": 10\r\n                },\r\n                \"2\": {\r\n                    \"name\": \"fountain\",\r\n                    \"x\": 10,\r\n                    \"y\": 10\r\n                }\r\n            },\r\n            \"buffs\": {\r\n                \"1\": {\r\n                    \"name\": \"heart\",\r\n                    \"x\": 10,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"enemies\": {\r\n                \"1\": {\r\n                    \"x\": 35,\r\n                    \"y\": 2\r\n                }\r\n            },\r\n            \"victoryLodge\": {\r\n                \"x\": 10,\r\n                \"y\": 2\r\n            },\r\n            \"abysses\": {\r\n                \"2\": {\r\n                    \"x1\": 25,\r\n                    \"x2\": 30\r\n                }\r\n            }\r\n        },\r\n\r\n    }\r\n    class Buff {\r\n        nameBuff;\r\n        src = 'img/buffs/';\r\n        x;\r\n        y;\r\n        blockSize;\r\n        decor;\r\n        text;\r\n        checkCollideTimer;\r\n\r\n        constructor(name, x, y) {\r\n            this.nameBuff = name;\r\n            this.x = x;\r\n            this.y = y;\r\n\r\n            this.definitionOfDecoration();\r\n\r\n            this.createDecor();\r\n            this.checkCollideTimer = setInterval(() => {\r\n                this.checkCollide()\r\n            }, 100);\r\n        }\r\n        definitionOfDecoration() {\r\n            switch (this.nameBuff) {\r\n                case \"heart\":\r\n                    this.blockSize = 45;\r\n                    this.src += \"heart.png\";\r\n                    this.text = \"+1\";\r\n                    break;\r\n                /* case \"fountain\":\r\n                    this.blockSize = 100;\r\n                    this.src += \"fountain.png\";\r\n                    break; */\r\n\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        createDecor() {\r\n            this.decor = document.createElement(\"div\");\r\n            const image = document.createElement(\"img\");\r\n            this.decor.classList.add(\"buff\");\r\n\r\n            this.decor.style.cssText = `\r\n                position: absolute;\r\n                left: ${this.x * 32}px;\r\n                bottom: ${this.y * 32}px;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n                overflow: hidden;\r\n                z-index: 3;\r\n            `;\r\n            allObjects.appendChild(this.decor);\r\n\r\n            image.src = this.src;\r\n            image.alt = \"buff\";\r\n            image.style.cssText = `\r\n                position: absolute;\r\n                left: 0;\r\n                bottom: 0;\r\n                width: ${this.blockSize}px;\r\n                height: ${this.blockSize}px;\r\n            `;\r\n            this.decor.appendChild(image);\r\n        }\r\n        checkCollide() {\r\n            const coordX = parseInt(this.decor.style.left) / 32 - -parseInt(allObjects.style.left) / 32 - heroX - 2;\r\n            if ((coordX > -1 && coordX < 1) && this.y === heroY) {\r\n                this.deathBuff();\r\n            }\r\n        }\r\n        deathBuff() {\r\n            this.decor.querySelector('img').style.cssText = \"transform: scale(0);\";\r\n            console.log(1);\r\n            clearInterval(this.checkCollideTimer);\r\n\r\n            this.showText();\r\n            \r\n            if (this.nameBuff === \"heart\") {\r\n                addHeart();\r\n            }\r\n        }\r\n        showText() {\r\n            const element = document.createElement(\"p\");\r\n            element.innerText = this.text;\r\n            element.style.cssText = `\r\n                color: red;\r\n                font-weight: 700;\r\n                font-size: 30px;\r\n                text-shadow: 1px 1px 2px #000;\r\n                position: absolute;\r\n                animation: showHurt 1s ease;\r\n                left: ${Number.parseInt(this.decor.style.left) - 32 * 7}px;\r\n                bottom: ${Number.parseInt(this.decor.style.bottom + 32)}px;\r\n            `;\r\n            game.appendChild(element);\r\n            setTimeout(() => {\r\n                element.parentNode.removeChild(element);\r\n            }, 1000);\r\n        }\r\n    }\r\n    class generateMap {\r\n\r\n        constructor() {\r\n\r\n            const urlParams = new URLSearchParams(window.location.search);\r\n            const levelNum = urlParams.get('level');\r\n            if (levelNum && levelNum in levels) {\r\n\r\n                const level = levels[levelNum];\r\n\r\n                //жизни\r\n                lives = level.lives;\r\n                maxLives = lives;\r\n                for (let index = 0.5; index < lives + 0.5; index++) {\r\n                    hearts.generateHearts(index, 0.5);\r\n                }\r\n\r\n                //платформы\r\n                Object.values(level.platforms).forEach((platform) => {\r\n                    createTilesPlatform(platform.x, platform.y, platform.length);\r\n                });\r\n\r\n                //Платформа основная с промежностями\r\n                let isAbyss = false;\r\n                for (let i = 0; i < level.mapLenght; i++) {\r\n                    //if (i > 10 && i < 20) continue;\r\n                    isAbyss = false;\r\n                    Object.values(level.abysses).forEach((abyss) => {\r\n                        if (i > abyss.x1 && i < abyss.x2) {\r\n                            isAbyss = true;\r\n                            return;\r\n                        }\r\n                    });\r\n                    if (isAbyss) continue;\r\n                    addTiles(i);\r\n                }\r\n\r\n                //Декорации\r\n                Object.values(level.decors).forEach((decor) => {\r\n                    new generateDecor(decor.name, decor.x, decor.y);\r\n                });\r\n\r\n                //Бафы\r\n                Object.values(level.buffs).forEach((buff) => {\r\n                    new Buff(buff.name, buff.x, buff.y);\r\n                });\r\n\r\n                //Монстры\r\n                Object.values(level.enemies).forEach((enemy) => {\r\n                    arrayEnemies.push(new Enemy(enemy.x, enemy.y));\r\n                });\r\n\r\n                //Победный дом\r\n                victoryLodge = new VictoryLodge(level.victoryLodge.x, level.victoryLodge.y);\r\n                victoryLodge.checkWin();\r\n\r\n            } else {\r\n                document.querySelector(\"[data-custom-popup='404']\").classList.add(\"open\");\r\n                statusGame = '404';\r\n                document.querySelector(\".wrapper\").classList.add(\"error\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    start();\r\n}\n\n//# sourceURL=webpack://newgulp/./src/js/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/app.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;